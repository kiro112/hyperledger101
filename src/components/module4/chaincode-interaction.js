import React, { Component } from 'react';

class ChaincodeInteraction extends Component {

    render() {
        return (
            <div>
                <h2>Chaincode calls chaincode</h2>
                <p>In many cases, process logic can best be handled with a modular approach in which some chaincode communicates with some other chaincode. So, does Hyperledger Fabric[1] offer an API function for interaction between chaincodes?</p>
                <p>We see the explanation for such a feature in <a href="https://github.com/hyperledger/fabric/blob/release-1.1/core/chaincode/shim/interfaces_stable.go">interfaces.go</a>:</p>
                <pre><code className="hljs golang">{"\n"}// InvokeChaincode locally calls the specified chaincode `Invoke` using the{"\n"}// same transaction context; that is, chaincode calling chaincode doesn't{"\n"}// create a new transaction message.{"\n"}// If the called chaincode is on the same channel, it simply adds the called{"\n"}// chaincode read set and write set to the calling transaction.{"\n"}// If the called chaincode is on a different channel,{"\n"}// only the Response is returned to the calling chaincode; any PutState calls{"\n"}// from the called chaincode will not have any effect on the ledger; that is,{"\n"}// the called chaincode on a different channel will not have its read set{"\n"}// and write set applied to the transaction. Only the calling chaincode's{"\n"}// read set and write set will be applied to the transaction. Effectively{"\n"}// the called chaincode on a different channel is a `Query`, which does not{"\n"}// participate in state validation checks in subsequent commit phase.{"\n"}// If `channel` is empty, the caller's channel is assumed.{"\n"}InvokeChaincode(chaincodeName string, args [][]byte, channel string) pb.Response{"\n"}</code></pre>
                <p>Ok, let's play with this function. After you learn to call a chaincode on the same channel, you'll also see how to call a chaincode on a different channel. The main difference to keep in mind is that you cannot change the state on the <em>other</em> channel. Implicitly, you are limited to query calls on <em>other</em> channels, so <code className="hljs hl-inline">Invoke</code> is not an option. </p>
                
                <h3>Chaincode calls chaincode on same channel</h3>
                <p>Let us make two chaincodes from <code className="hljs hl-inline">pcxchg.go</code>:</p>
                <ol>
                    <li>Producer chaincode(<code className="hljs hl-inline">producer.go</code>) with the function <code className="hljs hl-inline">createPC</code> installed on producers and markets peers.</li>
                    <li>Market chaincode(<code className="hljs hl-inline">market.go</code>) with the function <code className="hljs hl-inline">buyPC</code> installed on markets peers.</li>
                </ol>
                <p>To clarify, the market chaincode must access the producer data: </p>
                <ul>
                    <li>Let us keep the <code className="hljs hl-inline">queryDetail</code> function in the producer chaincode. Then we can use it to query the status of a given computer.</li>
                    <li>If the market chaincode is called and the caller wants to <code className="hljs hl-inline">buyPC</code>, it checks by calling the <code className="hljs hl-inline">producer</code> chaincode, to discover if the computer is available.</li>
                    <li>If the computer is indeed available, the <code className="hljs hl-inline">market</code> chaincode will update its status via <code className="hljs hl-inline">updateStatus</code> called on the <code className="hljs hl-inline">producer</code> chaincode.</li>
                </ul>
                <p><img src="https://s3-eu-west-1.amazonaws.com/b9-academy-assets/course-assets/HLF-0/cccall.png" /></p>
                <p>We will instantiate <code className="hljs hl-inline">producer</code> and <code className="hljs hl-inline">market</code> chaincode on the same channels. </p>
                <p>Let us start with <code className="hljs hl-inline">producer.go</code>, it will not call a chaincode, so there is nothing new:</p>
                <pre><code className="hljs golang">{"\n"}package main{"\n"}{"\n"}import ({"\n"}{"    "}"fmt"{"\n"}{"    "}"github.com/hyperledger/fabric/core/chaincode/shim"{"\n"}{"    "}pb "github.com/hyperledger/fabric/protos/peer"{"\n"}{"    "}"encoding/json"{"\n"}){"\n"}{"\n"}type Producer struct {"{"}{"\n"}{"}"}{"\n"}{"\n"}type PC struct {"{"}{"\n"}{"    "}Snumber string{"\n"}{"    "}Serie string{"\n"}{"    "}Others string{"\n"}{"    "}Status string{"\n"}{"}"}{"\n"}{"\n"}func (c *Producer) Init(stub shim.ChaincodeStubInterface) pb.Response {"{"} {"\n"}{"    "}return shim.Success(nil) {"\n"}{"}"}{"\n"}{"\n"}func (c *Producer) Invoke(stub shim.ChaincodeStubInterface) pb.Response {"{"} {"\n"}{"\n"}{"    "}function, args := stub.GetFunctionAndParameters(){"\n"}{"\n"}{"    "}switch function {"{"}{"\n"}{"    "}case "createPC":{"\n"}{"        "}return c.createPC(stub, args){"\n"}{"    "}case "updateStatus":{"\n"}{"        "}return c.updateStatus(stub, args){"\n"}{"    "}case "queryDetail":{"\n"}{"        "}return c.queryDetail(stub, args){"\n"}{"    "}default:{"\n"}{"        "}return shim.Error("Functions: createPC, updateStatus, queryDetail"){"\n"}{"    "}{"}"}{"\n"}{"}"}{"\n"}{"\n"}func main() {"{"}{"\n"}{"    "}err := shim.Start(new(Producer)){"\n"}{"    "}if err != nil {"{"}{"\n"}{"        "}fmt.Printf("Error starting chaincode sample: %s", err){"\n"}{"    "}{"}"}{"\n"}{"}"}{"\n"}</code></pre>
                <p>You can write the missing parts for practice. Have a look into <code className="hljs hl-inline">pcxchg.go</code>, it should help you with this. However, you can also use the implementations at the end of this section.</p>
                <p>Let's do something new and write <code className="hljs hl-inline">market.go</code>(keep in mind, you need separate folder for different chaincodes): </p>
                <pre><code className="hljs golang">{"\n"}package main{"\n"}{"\n"}import ({"\n"}{"    "}"github.com/hyperledger/fabric/core/chaincode/shim"{"\n"}{"    "}pb "github.com/hyperledger/fabric/protos/peer"{"\n"}{"    "}"fmt"{"\n"}){"\n"}{"\n"}type Market struct {"{"}{"\n"}{"}"}{"\n"}{"\n"}func (c *Market) Init(stub shim.ChaincodeStubInterface) pb.Response {"{"} {"\n"}{"    "}return shim.Success(nil) {"\n"}{"}"}{"\n"}{"\n"}func (c *Market) Invoke(stub shim.ChaincodeStubInterface) pb.Response {"{"} {"\n"}{"\n"}{"    "}function, args := stub.GetFunctionAndParameters(){"\n"}{"\n"}{"    "}if(function=="buyPC") {"{"}{"\n"}{"        "}if(len(args)!=2) {"{"}{"\n"}{"            "}return shim.Error("This function needs the serial number and the chaincode to be invoked"){"\n"}{"        "}{"}"}{"\n"}{"\n"}{"        "}callArgs:= make([][]byte, 3){"\n"}{"\n"}{"        "}callArgs[0]= []byte("updateStatus"){"\n"}{"        "}callArgs[1]= []byte(args[0]){"\n"}{"        "}callArgs[2]= []byte("bought"){"\n"}{"\n"}{"        "}return stub.InvokeChaincode(args[1],{"  "}callArgs, ""){"\n"}{"\n"}{"        "}{"}"} else {"{"}{"\n"}{"            "}return shim.Error("You can buyPC(serialnumber, chaincode)"){"\n"}{"        "}{"}"}{"\n"}{"\n"}{"        "}return shim.Success(nil){"\n"}{"}"}{"\n"}{"\n"}func main() {"{"}{"\n"}{"    "}err := shim.Start(new(Market)){"\n"}{"    "}if err != nil {"{"}{"\n"}{"        "}fmt.Printf("Error starting chaincode sample: %s", err){"\n"}{"    "}{"}"}{"\n"}{"}"}{"\n"}</code></pre>
                <p>Let's test them. You can use the <em>pcxchg</em> network for that. Start the network and join the peers to the channels. </p>
                <p>Then, install the chaincodes:</p>
                <pre><code className="hljs sh">{"\n"}docker exec cli.Asus bash -c 'peer chaincode install -p producer -n producer -v 0'{"\n"}docker exec cli.HP bash -c 'peer chaincode install -p producer -n producer -v 0'{"\n"}docker exec cli.Dell bash -c 'peer chaincode install -p producer -n producer -v 0'{"\n"}{"\n"}docker exec cli.Amazon bash -c 'peer chaincode install -p producer -n producer -v 0'{"\n"}docker exec cli.Amazon bash -c 'peer chaincode install -p market -n market -v 0'{"\n"}</code></pre>
                <p>Then, instantiate the chaincodes:</p>
                <pre><code className="hljs sh">{"\n"}docker exec cli.Asus bash -c "peer chaincode instantiate -C asus -n producer -v 0 -c '{"{"}\"Args\":[]{"}"}'"{"\n"}docker exec cli.HP bash -c "peer chaincode instantiate -C hp -n producer -v 0 -c '{"{"}\"Args\":[]{"}"}'"{"\n"}docker exec cli.Dell bash -c "peer chaincode instantiate -C dell -n producer -v 0 -c '{"{"}\"Args\":[]{"}"}'"{"\n"}{"\n"}docker exec cli.Amazon bash -c "peer chaincode instantiate -C asus -n market -v 0 -c '{"{"}\"Args\":[]{"}"}'"{"\n"}docker exec cli.Amazon bash -c "peer chaincode instantiate -C hp -n market -v 0 -c '{"{"}\"Args\":[]{"}"}'"{"\n"}docker exec cli.Amazon bash -c "peer chaincode instantiate -C dell -n market -v 0 -c '{"{"}\"Args\":[]{"}"}'"{"\n"}</code></pre>
                <p>Now, we can run a test. Let's create some PCs:</p>
                <pre><code className="hljs sh">{"\n"}docker exec cli.Asus bash -c "peer chaincode invoke -C asus -n producer -c '{"{"}\"Args\":[\"createPC\", \"Asus001\", \"foo\", \"bar\"]{"}"}'"{"\n"}{"\n"}docker exec cli.HP bash -c "peer chaincode invoke -C hp -n producer -c '{"{"}\"Args\":[\"createPC\", \"HP001\", \"foo\", \"bar\"]{"}"}'"{"\n"}{"\n"}docker exec cli.Dell bash -c "peer chaincode invoke -C dell -n producer -c '{"{"}\"Args\":[\"createPC\", \"Dell001\", \"foo\", \"bar\"]{"}"}'"{"\n"}docker exec cli.Dell bash -c "peer chaincode invoke -C dell -n producer -c '{"{"}\"Args\":[\"createPC\", \"Dell002\", \"foo\", \"bar\"]{"}"}'"{"\n"}</code></pre>
                <p>And it is time to buy a PC with the market chaincode:</p>
                <pre><code className="hljs sh">{"\n"}docker exec cli.Amazon bash -c "peer chaincode invoke -C dell -n market -c '{"{"}\"Args\":[\"buyPC\", \"Dell002\",\"producer\"]{"}"}'"{"\n"}</code></pre>
                <p>And verify it from producer:</p>
                <pre><code className="hljs sh">{"\n"}docker exec cli.Amazon bash -c "peer chaincode query -C dell -n producer -c '{"{"}\"Args\":[\"queryDetail\", \"Dell002\"]{"}"}'"{"\n"}</code></pre>
                <p>And, is it still available? Buy some other PCs.</p>
                
                <h4>Missing Parts</h4>
                <p>Here our reference implementation for <code className="hljs hl-inline">producer.go</code> functions:</p>
                <pre><code className="hljs golang">{"\n"}// createPC puts an aviable PC in the Blockchain{"\n"}func (c *Producer) createPC(stub shim.ChaincodeStubInterface, args []string) pb.Response {"{"}{"\n"}{"\n"}{"    "}if len(args) != 3 {"{"}{"\n"}{"        "}return shim.Error("createPC needs Serialnumber, Serie, Others as arguments"){"\n"}{"    "}{"}"}{"\n"}{"\n"}{"    "}pc := PC{"{"}args[0], args[1], args[2], "available"{"}"}{"\n"}{"\n"}{"    "}pcAsBytes, err := json.Marshal(pc){"\n"}{"    "}if err != nil {"{"}{"\n"}{"        "}return shim.Error(err.Error()){"\n"}{"    "}{"}"}{"\n"}{"\n"}{"    "}stub.PutState(pc.Snumber, pcAsBytes){"\n"}{"    "}return shim.Success(nil){"\n"}{"}"}{"\n"}{"\n"}// updateStatus handles sell and hand back{"\n"}func (c *Producer) updateStatus(stub shim.ChaincodeStubInterface, args []string) pb.Response {"{"}{"\n"}{"    "}if len(args) != 2 {"{"}{"\n"}{"        "}return shim.Error("This function needs the serial number and the new status as arguments"){"\n"}{"    "}{"}"}{"\n"}{"\n"}{"    "}v, err := stub.GetState(args[0]){"\n"}{"    "}if err != nil {"{"}{"\n"}{"        "}return shim.Error("Serialnumber " + args[0] + " not found "){"\n"}{"    "}{"}"}{"\n"}{"\n"}{"    "}var pc PC{"\n"}{"    "}json.Unmarshal(v, &amp;pc){"\n"}{"\n"}{"    "}pc.Status = args[1]{"\n"}{"    "}pcAsBytes, err := json.Marshal(pc){"\n"}{"\n"}{"    "}stub.PutState(pc.Snumber, pcAsBytes){"\n"}{"    "}return shim.Success(nil){"\n"}{"}"}{"\n"}{"\n"}// queryDetail gives all fields of stored data and want to have the serial number{"\n"}func (c *Producer) queryDetail(stub shim.ChaincodeStubInterface, args []string) pb.Response {"{"}{"\n"}{"\n"}{"    "}value, err := stub.GetState(args[0]) // look for the serial number{"\n"}{"    "}if err != nil {"{"}{"\n"}{"        "}return shim.Error("Serial number " + args[0] + " not found"){"\n"}{"    "}{"}"}{"\n"}{"\n"}{"    "}var pc PC{"\n"}{"    "}json.Unmarshal(value, &amp;pc) // decode value{"\n"}{"\n"}{"    "}fmt.Print(pc){"\n"}{"    "}return shim.Success([]byte(" SNMBR: " + pc.Snumber + " Serie: " + pc.Serie + " Others: " + pc.Others + " Status: " + pc.Status)) // response info{"\n"}{"}"}{"\n"}</code></pre>
                <p>[1] Contributed by IBM and Digital Asset Holdings, Hyperledger Fabric is one of five Hyperledger Projects hosted by The Linux Foundation.</p>
            </div>
        )
    }
}

export default ChaincodeInteraction;