import React, { Component } from 'react';

class Chaincode extends Component {

    render() {
        return (
            <div>
                <h2>Chaincode</h2>
                <p>We have a network so far. Now, we'll start interacting with it. Let's write the first version of our chaincode:</p>
                <p><img src="https://s3-eu-west-1.amazonaws.com/b9-academy-assets/course-assets/HLF-0/chaincode.png" /></p>
                <h3>Header</h3>
                <p>We'll start with the header. </p>
                <pre><code className="hljs golang">{"\n"}package main{"\n"}{"\n"}import ({"\n"}{"    "}"fmt"{"\n"}{"    "}"github.com/hyperledger/fabric/core/chaincode/shim"{"\n"}{"    "}pb "github.com/hyperledger/fabric/protos/peer"{"\n"}{"    "}"encoding/json"{"\n"}){"\n"}{"\n"}// Defined to implement chaincode interface{"\n"}type PcXchg struct {"{"}{"\n"}{"}"}{"\n"}{"\n"}// Define our struct to store PCs in Blockchain, start fields upper case for JSON{"\n"}type PC struct {"{"}{"\n"}{"    "}Snumber string{"  "}// This one will be our key{"\n"}{"    "}Serie string{"\n"}{"    "}Others string{"\n"}{"    "}Status string{"   "}// this will contain its status on the exchange{"\n"}{"}"}{"\n"}</code></pre>
                <p>The imported packages should look familiar. This time we also import the package <code className="hljs hl-inline">encode/json</code>. We will need it to de/serialise data we read from and write to the ledger. You are likely already familiar with the <a href="http://json.org/example.html">JSON format</a>.</p>
                <p>After that, we define a struct <code className="hljs hl-inline">PcXchg</code> to implement the <em>Chaincode interface</em>.</p>
                <p>We also define a struct <code className="hljs hl-inline">PC</code>, which is the format of the PCs stored in the ledger. Note that the member names must start with uppercase because the <code className="hljs hl-inline">JSON</code> package needs to access them.</p>
                <p>The serial number, <code className="hljs hl-inline">Snumber</code> will be our key.</p>
                <h3>Chaincode interface</h3>
                <p>Let's implement the fist method <code className="hljs hl-inline">Init</code>:</p>
                <pre><code className="hljs golang">{"\n"}// Implement Init{"\n"}func (c *PcXchg) Init(stub shim.ChaincodeStubInterface) pb.Response {"{"} {"\n"}{"    "}return shim.Success(nil) {"\n"}{"}"}{"\n"}</code></pre>
                <p>We don't need to initialise data so we can keep this empty.</p>
                <p>Now, let's implement <code className="hljs hl-inline">Invoke</code>:</p>
                <pre><code className="hljs golang">{"\n"}// Implement Invoke{"\n"}func (c *PcXchg) Invoke(stub shim.ChaincodeStubInterface) pb.Response {"{"} {"\n"}{"\n"}{"    "}// Get function name and args{"\n"}{"    "}function, args := stub.GetFunctionAndParameters(){"\n"}{"\n"}{"    "}switch function {"{"}{"\n"}{"    "}case "createPC":{"\n"}{"        "}// A computer is produced and available{"\n"}{"        "}return c.createPC(stub, args){"\n"}{"    "}case "buyPC":{"\n"}{"        "}// A market bought a computer{"\n"}{"        "}return c.updateStatus(stub, args, "bought"){"\n"}{"    "}case "handBackPC":{"\n"}{"        "}// A market handed back a computer{"\n"}{"        "}return c.updateStatus(stub, args, "returned"){"\n"}{"    "}case "queryStock":{"\n"}{"        "}// Stock query{"\n"}{"        "}return c.queryStock(stub, args){"\n"}{"    "}case "queryDetail":{"\n"}{"        "}// Get details of a computer{"\n"}{"        "}return c.queryDetail(stub, args){"\n"}{"    "}default:{"\n"}{"        "}return shim.Error("Available functions: createPC, buyPC, handBackPC, queryStock, queryDetail"){"\n"}{"    "}{"}"}{"\n"}{"}"}{"\n"}</code></pre>
                <p>Our chaincode offers a little more than we first described. The functions <code className="hljs hl-inline">queryStock</code> and <code className="hljs hl-inline">queryDetail</code> give us information about the inventory.</p>
                <p>Now, let's implement those functions. We start with <code className="hljs hl-inline">createPC</code>:</p>
                <pre><code className="hljs golang">{"\n"}// createPC puts an available PC in the Blockchain{"\n"}func (c *PcXchg) createPC(stub shim.ChaincodeStubInterface, args []string) pb.Response {"{"}{"\n"}{"\n"}{"    "}if len(args) != 3 {"{"}{"\n"}{"        "}return shim.Error("createPC arguments usage: Serialnumber, Serie, Others"){"\n"}{"    "}{"}"}{"\n"}{"\n"}{"    "}// A newly created computer is available{"\n"}{"    "}pc := PC{"{"}args[0], args[1], args[2], "available"{"}"} {"\n"}{"\n"}{"    "}// Use JSON to store in the Blockchain{"\n"}{"    "}pcAsBytes, err := json.Marshal(pc){"\n"}{"\n"}{"    "}if err != nil {"{"}{"\n"}{"        "}return shim.Error(err.Error()){"\n"}{"    "}{"}"}{"\n"}{"\n"}{"    "}// Use serial number as key{"\n"}{"    "}err = stub.PutState(pc.Snumber, pcAsBytes){"\n"}{"\n"}{"    "}if err != nil {"{"}{"\n"}{"        "}return shim.Error(err.Error()){"\n"}{"    "}{"}"}{"\n"}{"    "}return shim.Success(nil){"\n"}{"}"}{"\n"}</code></pre>
                <p>You can see it takes the three arguments that are members of our <code className="hljs hl-inline">PC struct</code>. They will be encoded in JSON and written in the <em>writeset</em>. </p>
                <p>What happens if Amazon buys a computer?</p>
                <pre><code className="hljs golang">{"\n"}// updateStatus handles sell and hand back{"\n"}func (c *PcXchg) updateStatus(stub shim.ChaincodeStubInterface, args []string, status string) pb.Response {"{"}{"\n"}{"    "}if len(args) != 1 {"{"}{"\n"}{"        "}return shim.Error("This function needs the serial number as argument"){"\n"}{"    "}{"}"}{"\n"}{"\n"}{"    "}// Look for the serial number{"\n"}{"    "}v, err := stub.GetState(args[0]){"\n"}{"    "}if err != nil {"{"}{"\n"}{"        "}return shim.Error("Serialnumber " + args[0] + " not found "){"\n"}{"    "}{"}"}{"\n"}{"\n"}{"    "}// Get Information from Blockchain{"\n"}{"    "}var pc PC{"\n"}{"    "}// Decode JSON data{"\n"}{"    "}json.Unmarshal(v, &amp;pc){"\n"}{"\n"}{"    "}// Change the status{"\n"}{"    "}pc.Status = status {"\n"}{"    "}// Encode JSON data{"\n"}{"    "}pcAsBytes, err := json.Marshal(pc){"\n"}{"\n"}{"    "}// Store in the Blockchain{"\n"}{"    "}err = stub.PutState(pc.Snumber, pcAsBytes){"\n"}{"    "}if err != nil {"{"}{"\n"}{"        "}return shim.Error(err.Error()){"\n"}{"    "}{"}"}{"\n"}{"\n"}{"    "}return shim.Success(nil){"\n"}{"}"}{"\n"}</code></pre>
                <p><code className="hljs hl-inline">updateStatus</code> is used by <code className="hljs hl-inline">buyPC</code> and <code className="hljs hl-inline">handBackPC</code> which update the <code className="hljs hl-inline">status</code> of the <code className="hljs hl-inline">PC</code>. This is a simple status field for this exercise. It indicates whether  or not Amazon purchased a particular PC.</p>
                <p>Let's implement the query functions:</p>
                <pre><code className="hljs golang">{"\n"}// queryDetail gives all fields of stored data and wants to have the serial number{"\n"}func (c *PcXchg) queryDetail(stub shim.ChaincodeStubInterface, args []string) pb.Response {"{"}{"\n"}{"\n"}{"    "}// Look for the serial number{"\n"}{"    "}value, err := stub.GetState(args[0]){"\n"}{"    "}if err != nil {"{"}{"\n"}{"        "}return shim.Error("Serial number " + args[0] + " not found"){"\n"}{"    "}{"}"}{"\n"}{"\n"}{"    "}var pc PC{"\n"}{"    "}// Decode value{"\n"}{"    "}json.Unmarshal(value, &amp;pc){"\n"}{"\n"}{"    "}fmt.Print(pc){"\n"}{"    "}// Response info{"\n"}{"    "}return shim.Success([]byte(" SNMBR: " + pc.Snumber + " Serie: " + pc.Serie + " Others: " + pc.Others + " Status: " + pc.Status)){"\n"}{"}"}{"\n"}</code></pre>
                <p>This should look familiar. We simply look for a key and decode the stored information in the ledger.</p>
                <p>The next one does a bit more:</p>
                <pre><code className="hljs golang">{"\n"}// queryStock give all stored keys in the database{"\n"}func (c *PcXchg) queryStock(stub shim.ChaincodeStubInterface, args []string) pb.Response {"{"}{"\n"}{"\n"}{"    "}// See stub.GetStateByRange in interfaces.go{"\n"}{"    "}start, end := "",""{"\n"}{"\n"}{"    "}if len(args) == 2 {"{"}{"\n"}{"        "}start, end = args[0], args[1]{"\n"}{"    "}{"}"} {"\n"}{"\n"}{"    "}// resultIterator is a StateQueryIteratorInterface{"\n"}{"    "}resultsIterator, err := stub.GetStateByRange(start, end){"\n"}{"    "}if err != nil {"{"}{"\n"}{"        "}return shim.Error(err.Error()){"\n"}{"    "}{"}"}{"\n"}{"    "}defer resultsIterator.Close(){"\n"}{"\n"}{"    "}keys := " \n"{"\n"}{"    "}// This interface includes HasNext,Close and Next{"\n"}{"    "}for resultsIterator.HasNext() {"{"}{"\n"}{"        "}queryResponse, err := resultsIterator.Next(){"\n"}{"        "}if err != nil {"{"}{"\n"}{"            "}return shim.Error(err.Error()){"\n"}{"        "}{"}"}{"\n"}{"        "}keys+=queryResponse.Key + " \n"{"\n"}{"    "}{"}"}{"\n"}{"\n"}{"    "}fmt.Println(keys){"\n"}{"\n"}{"    "}return shim.Success([]byte(keys)){"\n"}{"}"}{"\n"}</code></pre>
                <p>This iterates through the results. We use <code className="hljs hl-inline">GetStateByRange</code>. You can dive into <code className="hljs hl-inline">interfaces.go</code> to see what it needs and what it returns.</p>
                <h3>Main</h3>
                <p>Importantly, we implement the <code className="hljs hl-inline">main</code>:</p>
                <pre><code className="hljs golang">{"\n"}func main() {"{"}{"\n"}{"    "}err := shim.Start(new(PcXchg)){"\n"}{"    "}if err != nil {"{"}{"\n"}{"        "}fmt.Printf("Error starting chaincode sample: %s", err){"\n"}{"    "}{"}"}{"\n"}{"}"}{"\n"}</code></pre>
                <h3>All together</h3>
                <p>Here is the source code for our chaincode:</p>
                <pre><code className="hljs golang">{"\n"}package main{"\n"}{"\n"}import ({"\n"}{"    "}"fmt"{"\n"}{"    "}"github.com/hyperledger/fabric/core/chaincode/shim" // import for Chaincode Interface{"\n"}{"    "}pb "github.com/hyperledger/fabric/protos/peer"{"      "}// import for peer response{"\n"}{"    "}"encoding/json"{"\n"}){"\n"}{"\n"}// Defined to implement chaincode interface{"\n"}type PcXchg struct {"{"}{"\n"}{"}"}{"\n"}{"\n"}// Define our struct to store PCs in Blockchain, start fields upper case for JSON{"\n"}type PC struct {"{"}{"\n"}{"    "}Snumber string{"  "}// This one will be our key{"\n"}{"    "}Serie string{"\n"}{"    "}Others string{"\n"}{"    "}Status string{"   "}// this will contain its status on the exchange{"\n"}{"}"}{"\n"}{"\n"}// Implement Init{"\n"}func (c *PcXchg) Init(stub shim.ChaincodeStubInterface) pb.Response {"{"} {"\n"}{"    "}return shim.Success(nil) {"\n"}{"}"}{"\n"}{"\n"}// Implement Invoke{"\n"}func (c *PcXchg) Invoke(stub shim.ChaincodeStubInterface) pb.Response {"{"} {"\n"}{"\n"}{"    "}function, args := stub.GetFunctionAndParameters() // get function name and args{"\n"}{"\n"}{"    "}switch function {"{"}{"\n"}{"    "}case "createPC":{"\n"}{"        "}// A computer is produced and available{"\n"}{"        "}return c.createPC(stub, args){"\n"}{"    "}case "buyPC":{"\n"}{"        "}// A market bought a computer{"\n"}{"        "}return c.updateStatus(stub, args, "bought"){"\n"}{"    "}case "handBackPC":{"\n"}{"        "}// A market handed back a computer{"\n"}{"        "}return c.updateStatus(stub, args, "returned"){"\n"}{"    "}case "queryStock":{"\n"}{"        "}// Stock query{"\n"}{"        "}return c.queryStock(stub, args){"\n"}{"    "}case "queryDetail":{"\n"}{"        "}// Get details of a computer{"\n"}{"        "}return c.queryDetail(stub, args){"\n"}{"    "}default:{"\n"}{"        "}return shim.Error("Available functions: createPC, buyPC, handBackPC, queryStock, queryDetail"){"\n"}{"    "}{"}"}{"\n"}{"}"}{"\n"}{"\n"}// createPC puts an available PC in the Blockchain{"\n"}func (c *PcXchg) createPC(stub shim.ChaincodeStubInterface, args []string) pb.Response {"{"}{"\n"}{"\n"}{"    "}if len(args) != 3 {"{"}{"\n"}{"        "}return shim.Error("createPC arguments usage: Serialnumber, Serie, Others"){"\n"}{"    "}{"}"}{"\n"}{"\n"}{"    "}// A newly created computer is available{"\n"}{"    "}pc := PC{"{"}args[0], args[1], args[2], "available"{"}"}{"\n"}{"\n"}{"    "}// Use JSON to store in the Blockchain{"\n"}{"    "}pcAsBytes, err := json.Marshal(pc){"\n"}{"\n"}{"    "}if err!=nil {"{"}{"\n"}{"        "}return shim.Error(err.Error()){"\n"}{"    "}{"}"}{"\n"}{"\n"}{"    "}// Use serial number as key{"\n"}{"    "}err = stub.PutState(pc.Snumber, pcAsBytes){"\n"}{"\n"}{"    "}if err != nil {"{"}{"\n"}{"        "}return shim.Error(err.Error()){"\n"}{"    "}{"}"}{"\n"}{"    "}return shim.Success(nil){"\n"}{"}"}{"\n"}{"\n"}// updateStatus handles sell and hand back{"\n"}func (c *PcXchg) updateStatus(stub shim.ChaincodeStubInterface, args []string, status string) pb.Response {"{"}{"\n"}{"    "}if len(args) != 1 {"{"}{"\n"}{"        "}return shim.Error("This function needs the serial number as argument"){"\n"}{"    "}{"}"}{"\n"}{"\n"}{"    "}// Look for the serial number{"\n"}{"    "}v, err := stub.GetState(args[0]){"\n"}{"    "}if err != nil {"{"}{"\n"}{"        "}return shim.Error("Serialnumber " + args[0] + " not found "){"\n"}{"    "}{"}"}{"\n"}{"\n"}{"    "}// Get Information from Blockchain{"\n"}{"    "}var pc PC{"\n"}{"    "}// Decode JSON data{"\n"}{"    "}json.Unmarshal(v, &amp;pc){"\n"}{"\n"}{"    "}// Change the status{"\n"}{"    "}pc.Status = status{"\n"}{"    "}// Encode JSON data{"\n"}{"    "}pcAsBytes, err := json.Marshal(pc){"\n"}{"\n"}{"    "}// Store in the Blockchain{"\n"}{"    "}err = stub.PutState(pc.Snumber, pcAsBytes){"\n"}{"    "}if err != nil {"{"}{"\n"}{"        "}return shim.Error(err.Error()){"\n"}{"    "}{"}"}{"\n"}{"    "}return shim.Success(nil){"\n"}{"}"}{"\n"}{"\n"}// queryStock gives all stored keys in the database{"\n"}func (c *PcXchg) queryStock(stub shim.ChaincodeStubInterface, args []string) pb.Response {"{"}{"\n"}{"\n"}{"    "}// See stub.GetStateByRange in interfaces.go{"\n"}{"    "}start, end := "",""{"\n"}{"\n"}{"    "}if len(args) == 2 {"{"}{"\n"}{"        "}start, end = args[0], args[1]{"\n"}{"    "}{"}"} {"\n"}{"\n"}{"    "}// resultIterator is a StateQueryIteratorInterface{"\n"}{"    "}resultsIterator, err := stub.GetStateByRange(start, end){"\n"}{"    "}if err != nil {"{"}{"\n"}{"        "}return shim.Error(err.Error()){"\n"}{"    "}{"}"}{"\n"}{"    "}defer resultsIterator.Close(){"\n"}{"\n"}{"    "}keys := " \n"{"\n"}{"    "}// This interface includes HasNext,Close and Next{"\n"}{"    "}for resultsIterator.HasNext() {"{"}{"\n"}{"        "}queryResponse, err := resultsIterator.Next(){"\n"}{"        "}if err != nil {"{"}{"\n"}{"            "}return shim.Error(err.Error()){"\n"}{"        "}{"}"}{"\n"}{"        "}keys += queryResponse.Key + " \n"{"\n"}{"    "}{"}"}{"\n"}{"\n"}{"    "}fmt.Println(keys){"\n"}{"\n"}{"    "}return shim.Success([]byte(keys)){"\n"}{"}"}{"\n"}{"\n"}// queryDetail gives all fields of stored data and needs the serial number{"\n"}func (c *PcXchg) queryDetail(stub shim.ChaincodeStubInterface, args []string) pb.Response {"{"}{"\n"}{"\n"}{"    "}// Look for the serial number{"\n"}{"    "}value, err := stub.GetState(args[0]){"\n"}{"    "}if err != nil {"{"}{"\n"}{"            "}return shim.Error("Serial number " + args[0] +" not found"){"\n"}{"        "}{"}"}{"\n"}{"\n"}{"    "}var pc PC{"\n"}{"    "}// Decode value{"\n"}{"    "}json.Unmarshal(value, &amp;pc){"\n"}{"\n"}{"    "}fmt.Print(pc){"\n"}{"    "}// Response info{"\n"}{"    "}return shim.Success([]byte(" SNMBR: " + pc.Snumber + " Serie: " + pc.Serie + " Others: " + pc.Others + " Status: " + pc.Status)){"\n"}{"}"}{"\n"}{"\n"}func main() {"{"}{"\n"}{"    "}err := shim.Start(new(PcXchg)){"\n"}{"    "}if err != nil {"{"}{"\n"}{"        "}fmt.Printf("Error starting chaincode sample: %s", err){"\n"}{"    "}{"}"}{"\n"}{"}"}{"\n"}</code></pre>
                <p>Save this file as <code className="hljs hl-inline">pcxchg/chaincode/pcxchg/pcxchg.go</code>.</p>
                <div className="b9-tip">
                <p>You may find that your <code className="hljs hl-inline">chaincode</code> folder is created with <code className="hljs hl-inline">root</code> ownership and safe permissions. If so, then to create the folders, as instructed below, you will have to grant the current user write permission. A "Not Safe For Production" method is to use the linux command <code className="hljs hl-inline">chmod 755 chaincode</code> from your <code className="hljs hl-inline">pcxchg</code> folder. </p>
                </div>
                <h3>Deploy</h3>
                <p>Now, let's deploy this chaincode in the network. Ensure your network is running and each peer has joined the right channel. 
                </p><div className="b9-warning">
                <p>
                    If you start the network, you will need to recreate the channels and join the peers. This happens because we didn’t map some folders. So, you have more or less the initial state, if you run <code>docker-compose up</code>.
                </p>
                If you want to keep the blockchain after a <code>docker-compose down</code>, you will need to map it to your host, e.g. <br />
                <code>- ./orderer.pcxchg.com:/var/hyperledger/production/orderer</code> for the orderer<br />
                <code>- ./peer0.Asus.com:/var/hyperledger/production</code> for the Asus peer.
                </div>
                First, we install this chaincode on each peer:<p />
                <pre><code className="hljs sh">{"\n"}docker exec cli.Asus bash -c 'peer chaincode install -p pcxchg -n pcxchg -v 0'{"\n"}docker exec cli.HP bash -c 'peer chaincode install -p pcxchg -n pcxchg -v 0'{"\n"}docker exec cli.Dell bash -c 'peer chaincode install -p pcxchg -n pcxchg -v 0'{"\n"}docker exec cli.Amazon bash -c 'peer chaincode install -p pcxchg -n pcxchg -v 0'{"\n"}</code></pre>
                <p>Next, we instantiate the chaincode on each channel:</p>
                <pre><code className="hljs sh">{"\n"}docker exec cli.Asus bash -c "peer chaincode instantiate -C asus -n pcxchg -v 0 -c '{"{"}\"Args\":[]{"}"}'"{"\n"}docker exec cli.HP bash -c "peer chaincode instantiate -C hp -n pcxchg -v 0 -c '{"{"}\"Args\":[]{"}"}'"{"\n"}docker exec cli.Dell bash -c "peer chaincode instantiate -C dell -n pcxchg -v 0 -c '{"{"}\"Args\":[]{"}"}'"{"\n"}</code></pre>
                <div className="b9-tip">
                <p>
                    If you instantiate a chaincode, an image will be created. The correct way to update a chaincode is using <code>peer chaincode upgrade</code>. 
                    <br />However, if you want to change the chaincode and test the network in the same way you did the first time, you will need to remove this image. You can list all images with <code>docker images</code> and remove an image with <code>docker rmi</code>, e.g. <code>docker rmi dev-peer0.amazon.com-pcxchg-0 -f</code> for the Amazon peer.
                </p>
                </div>
                <h3>Try it!</h3>
                <p>Now let's create some PCs:</p>
                <pre><code className="hljs sh">{"\n"}docker exec cli.Asus bash -c "peer chaincode invoke -C asus -n pcxchg -c '{"{"}\"Args\":[\"createPC\", \"Asus001\", \"foo\", \"bar\"]{"}"}'"{"\n"}docker exec cli.Asus bash -c "peer chaincode invoke -C asus -n pcxchg -c '{"{"}\"Args\":[\"createPC\", \"Asus002\", \"foo\", \"bar\"]{"}"}'"{"\n"}docker exec cli.Asus bash -c "peer chaincode invoke -C asus -n pcxchg -c '{"{"}\"Args\":[\"createPC\", \"Asus003\", \"foo\", \"bar\"]{"}"}'"{"\n"}{"\n"}docker exec cli.HP bash -c "peer chaincode invoke -C hp -n pcxchg -c '{"{"}\"Args\":[\"createPC\", \"HP001\", \"foo\", \"bar\"]{"}"}'"{"\n"}docker exec cli.HP bash -c "peer chaincode invoke -C hp -n pcxchg -c '{"{"}\"Args\":[\"createPC\", \"HP002\", \"foo\", \"bar\"]{"}"}'"{"\n"}{"\n"}docker exec cli.Dell bash -c "peer chaincode invoke -C dell -n pcxchg -c '{"{"}\"Args\":[\"createPC\", \"Dell001\", \"foo\", \"bar\"]{"}"}'"{"\n"}docker exec cli.Dell bash -c "peer chaincode invoke -C dell -n pcxchg -c '{"{"}\"Args\":[\"createPC\", \"Dell002\", \"foo\", \"bar\"]{"}"}'"{"\n"}docker exec cli.Dell bash -c "peer chaincode invoke -C dell -n pcxchg -c '{"{"}\"Args\":[\"createPC\", \"Dell003\", \"foo\", \"bar\"]{"}"}'"{"\n"}docker exec cli.Dell bash -c "peer chaincode invoke -C dell -n pcxchg -c '{"{"}\"Args\":[\"createPC\", \"Dell004\", \"foo\", \"bar\"]{"}"}'"{"\n"}</code></pre>
                <p>Did it work? Let's run some queries:</p>
                <pre><code className="hljs sh">{"\n"}docker exec cli.Amazon bash -c "peer chaincode query -C asus -n pcxchg -c '{"{"}\"Args\":[\"queryStock\"]{"}"}'"{"\n"}docker exec cli.Amazon bash -c "peer chaincode query -C hp -n pcxchg -c '{"{"}\"Args\":[\"queryStock\"]{"}"}'"{"\n"}docker exec cli.Amazon bash -c "peer chaincode query -C dell -n pcxchg -c '{"{"}\"Args\":[\"queryStock\"]{"}"}'"{"\n"}</code></pre>
                <p>Maybe Amazon should buy a computer now:</p>
                <pre><code className="hljs sh">{"\n"}docker exec cli.Amazon bash -c "peer chaincode invoke -C dell -n pcxchg -c '{"{"}\"Args\":[\"buyPC\", \"Dell004\"]{"}"}'"{"\n"}</code></pre>
                <p>Ok, Amazon has one Dell PC, but they need more. Let's look at the details of an Asus model before we buy it:</p>
                <pre><code className="hljs sh">{"\n"}docker exec cli.Amazon bash -c "peer chaincode query -C asus -n pcxchg -c '{"{"}\"Args\":[\"queryDetail\", \"Asus003\"]{"}"}'"{"\n"}</code></pre>
                <p>Let's buy another one to try it out:</p>
                <pre><code className="hljs sh">{"\n"}docker exec cli.Amazon bash -c "peer chaincode invoke -C asus -n pcxchg -c '{"{"}\"Args\":[\"buyPC\", \"Asus003\"]{"}"}'"{"\n"}</code></pre>
                <p>After a few weeks... or a few seconds, this computer does not meet the requirements, so let us give it back:</p>
                <pre><code className="hljs sh">{"\n"}docker exec cli.Amazon bash -c "peer chaincode invoke -C asus -n pcxchg -c '{"{"}\"Args\":[\"handBackPC\", \"Asus003\"]{"}"}'"{"\n"}</code></pre>
                <p>And buy more Dell computers instead:</p>
                <pre><code className="hljs sh">{"\n"}docker exec cli.Amazon bash -c "peer chaincode invoke -C dell -n pcxchg -c '{"{"}\"Args\":[\"buyPC\", \"Dell004\"]{"}"}'"{"\n"}</code></pre>
                <p>We suggest you practice with these commands until you get comfortable. You should also trade with HP. Can you work that out on your own?</p>
                <div className="b9-tip">
                We don't create any logs in our chaincode, unless it fails to start, but if you want to do so, you can use e.g. <code>docker logs dev-peer0.Asus.com-pcxchg-0</code> to see the logs.
                </div>
                <h3>Permissions</h3>
                <p>Did you notice a problem with this arrangement?</p>
                <p>Amazon could also call <code className="hljs hl-inline">createPC</code>. Or Asus could <code className="hljs hl-inline">buyPC</code>. </p>
                <p>The possibility of misuse is one of the arguments in support of permissioned blockchains. Permissioned ledgers give us accountability. If someone behaves maliciously, we can figure out who did it, how they did it and what they did. We can restore the valid version(because every change is tracked) and we can ban the culprit from the channel or network.</p>
                <p>Obviously, it is much better to prevent that sort of event with access control. We'll want permissions and restricted access for chaincode functions. We'll cover this soon.</p>
                <h3>CouchDB</h3>
                <p>You may want to access your blockchain data directly, without using <em>peer channel fetch</em>. To enable this we'll create a CouchDB container for Amazon. Why Amazon? Because Amazon is connected to all three channels and therefore has the most comprehensive view of the data.</p>
                <p>Before we adjust the configuration, if your network is running: 
                <code className="hljs hl-inline">bash
                    docker-compose -f docker-compose-pcxchg.yaml down
                </code></p>
                <p>You configure that in <code className="hljs hl-inline">docker-compose-pcxchg.yaml</code>. There you can put:</p>
                <pre><code className="hljs yaml">{"\n"}{"  "}couchdbAmazon:{"\n"}{"    "}container_name: couchdbAmazon{"\n"}{"    "}image: hyperledger/fabric-couchdb{"\n"}{"    "}environment:{"\n"}{"      "}DB_URL: http://localhost:5984/{"\n"}{"    "}ports:{"\n"}{"      "}- "5984:5984"{"\n"}{"    "}networks:{"\n"}{"      "}- pcxchg{"\n"}</code></pre>
                <p>That will run a CouchDB container. Now, we'll tell <code className="hljs hl-inline">peer0.Amazon.com</code> that we have a CouchDB container, so change the settings for that to:</p>
                <pre><code className="hljs yaml">{"\n"}{"  "}peer0.Amazon.com:{"\n"}{"    "}container_name: peer0.Amazon.com{"\n"}{"    "}extends:{"\n"}{"      "}file: ./peer.yaml{"\n"}{"      "}service: peer{"\n"}{"    "}environment:{"\n"}{"      "}- CORE_PEER_ID=peer0.Amazon.com{"\n"}{"      "}- CORE_PEER_ADDRESS=peer0.Amazon.com:7051{"\n"}{"      "}- CORE_PEER_LOCALMSPID=AmazonMSP{"\n"}{"      "}- CORE_PEER_MSPCONFIGPATH=/etc/hyperledger/msp/peer/{"\n"}{"      "}- CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.Amazon.com:7051{"\n"}{"      "}- CORE_LEDGER_STATE_STATEDATABASE=CouchDB{"\n"}{"      "}- CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=couchdbAmazon:5984{"\n"}{"    "}volumes:{"\n"}{"      "}- ./crypto-config/peerOrganizations/Amazon.com/peers/peer0.Amazon.com/msp:/etc/hyperledger/msp/peer{"\n"}{"    "}ports:{"\n"}{"      "}- 8051:7051{"\n"}{"      "}- 8053:7053{"\n"}{"    "}depends_on:{"\n"}{"      "}- orderer.pcxchg.com{"\n"}{"      "}- couchdbAmazon{"\n"}{"    "}networks:{"\n"}{"      "}- pcxchg{"\n"}</code></pre>
                <p>Now, it uses CouchDB. The good thing is, CouchDB offers an UI. You can explore the data in the running network with your browser. </p>
                <p>Start the network:
                <code className="hljs hl-inline">bash
                    docker-compose -f docker-compose-pcxchg.yaml up -d
                </code></p>
                <p>Go to <a href="http://localhost:5984/_utils/#_all_dbs">http://localhost:5984/_utils/#_all_dbs</a>.</p>
                <p><img src="https://s3-eu-west-1.amazonaws.com/b9-academy-assets/course-assets/HLF-0/couchDB.png" /></p>
                <p>Play with the network some more and see how your DB changes. 
                Do a query with Mango. First try the template it offers. 
                It's a <a href="https://en.wikipedia.org/wiki/NoSQL">NoSQL database</a>. You can learn about the syntax <a href="https://developer.ibm.com/clouddataservices/cloudant-query-new/#.V55KCOaAOko">here</a>.</p>
                <div className="b9-warning">
                In production, you will need to hide the port mapping. It is also recommended to set <code>COUCHDB_USER</code> and <code>COUCHDB_PASSWORD</code>
                </div>
                <div className="vert vert-1" data-id="block-v1:B9lab+HLF-12+2018-07+type@video+block@566b7c3c13b44ccab6da2d648711adc2">
                <div className="xblock xblock-student_view xblock-student_view-video xmodule_display xmodule_VideoModule" data-runtime-class="LmsRuntime" data-init="XBlockToXModuleShim" data-block-type="video" data-request-token="a4d900f096b511e8be120a059cba8688" data-runtime-version={1} data-usage-id="block-v1:B9lab+HLF-12+2018-07+type@video+block@566b7c3c13b44ccab6da2d648711adc2" data-type="Video" data-course-id="course-v1:B9lab+HLF-12+2018-07">
                    <h3 className="hd hd-2">Watch Rob set up the chaincode</h3>
                    <iframe src="https://www.youtube.com/embed/AdNTC68JCkc" allow="autoplay; encrypted-media" allowFullScreen width={809} height={455} frameBorder={0} />
                </div>
                </div>
            </div>
        )
    }
}

export default Chaincode;