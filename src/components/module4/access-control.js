import React, { Component } from 'react';

class AccessControl extends Component {

    render() {
        return (
            <div>
                <h2>Chaincode Access control</h2>
                <p>Hyperledger Fabric[1] offers multiple chaincode access control mechanisms. Let's explore them. We will change our chaincode in such a way, that only Amazon can call <code className="hljs hl-inline">buyPC</code> and only a producer can call <code className="hljs hl-inline">createPC</code>.</p>
                
                <h3>GetCreator</h3>
                <p><a href="https://github.com/hyperledger/fabric/blob/release-1.1/core/chaincode/shim/interfaces_stable.go">interfaces.go</a> contains a function called <code className="hljs hl-inline">GetCreator</code>:</p>
                <pre><code className="hljs golang">{"\n"}// GetCreator returns `SignatureHeader.Creator` (e.g. an identity){"\n"}// of the `SignedProposal`. This is the identity of the agent (or user){"\n"}// submitting the transaction.{"\n"}GetCreator() ([]byte, error){"\n"}</code></pre>
                <p>We can determine the chaincode caller with this function. You can find the protocol buffer for <code className="hljs hl-inline">SignatureHeader</code> <a href="https://github.com/hyperledger/fabric/blob/release-1.1/protos/common/common.proto">here</a>.</p>
                <p>So, one can use this mechanism to control function calls. It includes some problems that we will mention later.</p>
                <p>Let's record the chaincode creator. Replace <code className="hljs hl-inline">Init</code> in <code className="hljs hl-inline">pcxchg.go</code> with:</p>
                <pre><code className="hljs golang">{"\n"}func (c *PcXchg) Init(stub shim.ChaincodeStubInterface) pb.Response {"{"} {"\n"}{"    "}creatorByte, err := stub.GetCreator(){"\n"}{"    "}if(err != nil) {"{"}{"\n"}{"        "}return shim.Error("GetCreator err"){"\n"}{"    "}{"}"}{"\n"}{"    "}stub.PutState(string(creatorByte), []byte("producer")){"\n"}{"    "}return shim.Success(nil) {"\n"}{"}"}{"\n"}</code></pre>
                <p>What did we just do? Remember, <code className="hljs hl-inline">Init</code> will be called, if someone instantiates the chaincode. We simply get the identity of this person and we store it in the ledger. Later, we will compare this stored identity with the identity of the function caller and further decide whether it is able to proceed.</p>
                <p><img src="https://s3-eu-west-1.amazonaws.com/b9-academy-assets/course-assets/HLF-0/control.png" /></p>
                <p>This works because we instantiate the chaincode with the producers in the channels. (See the section chaincode) 
                If the caller is the same caller who instantiated the chaincode, then he is a producer and can <code className="hljs hl-inline">createPC</code>. Let us implement this. </p>
                <p>We have to change our <code className="hljs hl-inline">Invoke</code> to check that:</p>
                <pre><code className="hljs golang">{"\n"}func (c *PcXchg) Invoke(stub shim.ChaincodeStubInterface) pb.Response {"{"}{"\n"}{"\n"}{"    "}// Get function name and args{"\n"}{"    "}function, args := stub.GetFunctionAndParameters(){"\n"}{"\n"}{"    "}// Check if the producer calls the chaincode{"\n"}{"    "}if c.producer(stub) {"{"}{"\n"}{"        "}if function == "createPC" {"{"}{"\n"}{"            "}// A computer is produced and available{"\n"}{"            "}return c.createPC(stub, args){"\n"}{"        "}{"}"}{"\n"}{"    "}{"}"} else {"{"}{"\n"}{"        "}if function == "buyPC" {"{"}{"\n"}{"            "}// A market bought a computer{"\n"}{"            "}return c.updateStatus(stub, args, "bought"){"\n"}{"        "}{"}"} else if function == "handBackPC" {"{"}{"\n"}{"            "}// A market handed back a computer{"\n"}{"            "}return c.updateStatus(stub, args, "returned"){"\n"}{"        "}{"}"}{"\n"}{"    "}{"}"}{"\n"}{"\n"}{"    "}if function == "queryStock" {"{"}{"\n"}{"        "}// Stock query{"\n"}{"        "}return c.queryStock(stub, args){"\n"}{"    "}{"}"} else if function == "queryDetail" {"{"}{"\n"}{"        "}// Get details of a computer{"\n"}{"        "}return c.queryDetail(stub, args){"\n"}{"    "}{"}"}{"\n"}{"\n"}{"    "}return shim.Error("You can call createPc as producer and buyPC/handBackPC as market. Producer and market can call queryStock, queryDetail"){"\n"}{"}"}{"\n"}</code></pre>
                <p>As you can see, we use a function <code className="hljs hl-inline">producer</code> to check if the producer on the channel is the entity calling the chaincode. We have to write this function:</p>
                <pre><code className="hljs golang">{"\n"}func (c *PcXchg) producer(stub shim.ChaincodeStubInterface) bool {"{"}{"\n"}{"    "}creatorByte, _ := stub.GetCreator(){"\n"}{"    "}v, err := stub.GetState(string(creatorByte)){"\n"}{"    "}if (err != nil) {"{"}{"\n"}{"        "}return false{"\n"}{"    "}{"}"}{"\n"}{"    "}return string(v) == "producer";{"\n"}{"}"}{"\n"}</code></pre>
                <p>That's it! Now, only a producer in the channel can call <code className="hljs hl-inline">createPC</code>.</p>
                <div className="b9-warning">
                <p>
                    Since you have altered <code>pcxchg.go</code>, you need to remove the old images with: <code>docker rmi --force $(docker images -q dev-peer*)</code> if  you want to keep the name/version pcxchg/0.
                    Please do not use CouchDB, it cannot handle non UTF-8 strings like our certificate. 
                </p>
                </div>
                <p>This time, try to create something that shouldn't be allowed. For example, see if Amazon can create a PC or if Asus can buy one. Those actions should not be allowed. </p>
                
                <h3>Advanced - Explainer</h3>
                <p>There are two problems with this approach:</p>
                <ol>
                    <li>We do not check the authenticity of the certificate. We just compare it with the certificate at the time of instantiation to confirm it is the same certificate as before. This is because the chaincode does not have access to the CA certificates.</li>
                    <li>Protobuf does not guarantee a deterministic serialisation. The can result in a false mismatch because you might get the exact same bytes if you serialize the certificate twice.<br /></li>
                </ol>
                <p>We can solve the second problem. The simplest solution is to use following packages:</p>
                <pre><code className="hljs golang">{"\n"}import({"\n"}{"    "}"github.com/golang/protobuf/proto"{"\n"}{"    "}"github.com/hyperledger/fabric/protos/msp"{"\n"}){"\n"}</code></pre>
                <p>And use them to deserialise the <code className="hljs hl-inline">SignatureHeader</code> then decode the certificate. This would work like:</p>
                <pre><code className="hljs golang">{"\n"}// Get serialised data{"\n"}serialised, _ := stub.GetCreator(){"\n"}{"\n"}// Use protobuf to deserialise data{"\n"}var id msp.SerializedIdentity{"\n"}proto.Unmarshal(serialised, &amp;id){"\n"}</code></pre>
                <p>Using <code className="hljs hl-inline">protobuf</code> will ensure you get the same message every time. This will tend toward proper matching, whereas the comparison of bytes will lead to occasional false mismatches. </p>
                <p>However, this causes a new problem. The packages we need to import therefore are not included in the chaincode container. So, we have to "vendor" them.</p>
                <p><a href="https://www.youtube.com/watch?v=-mlUaJbFHcM">Watch</a> to learn how to "vendor" packages for your chaincode. You can get the <code className="hljs hl-inline">govendor</code> tool used in that video with <code className="hljs hl-inline">go get -u github.com/kardianos/govendor</code> e.g. in the chaincode container by using <em>dev mode</em>.</p>
                <div className="b9-tip">
                <p>Hyperledger Fabric v1.1 offers a <a href="https://jira.hyperledger.org/browse/FAB-6089">better approach</a>. It is called ABAC(<a href="https://docs.google.com/document/d/1GP5tcN0oK9Zewed9h5pLiM2BowWPhtgFUGXEDKjeGGo/edit#heading=h.mhkdcy93sifd">Attribute-Based Access Control</a>).
                    It is not fully <a href="https://jira.hyperledger.org/browse/FAB-9081">integrated</a> yet, but <a href="https://github.com/hyperledger/fabric/tree/v1.1.0-preview/core/chaincode/lib/cid">it can be used with vendoring</a>. 
                    However, you will need to wait to learn Fabric-CA before you can test it.</p>
                </div>
                <h3>Endorsement policies</h3>
                <p>Another way to control the chaincode access is using endorsement policies during instantiation. This differs from control at the chaincode level, because you do not determine permissions at the functions level but for the chaincode as a whole. In other words, access control is not embedded in chaincode itself, but rather it is managed as a network administration process. </p>
                <p>Imagine, we want to invite Dell in the Asus channel as an auditor.</p>
                <p>How can we define the permissions such that Dell is not able to invoke the chaincode? We do this with:</p>
                <pre><code className="hljs sh">{"\n"}peer chaincode instantiate -C asus -n pcxchg -v 0 -c '{"{"}"Args":[]{"}"}' -P "OR ('AsusMSP.member','AmazonMSP.member')"{"\n"}</code></pre>
                <p>You can use that to provide read-only access to a channel, as in the case of inviting a regulator to observe channel activity. </p>
                <p>You will have to update <code className="hljs hl-inline">configtx.yaml</code> to include the regulator in the channel block, and you will have to join the regulator to the channel with <code className="hljs hl-inline">peer channel join</code>. </p>
                <p>In Hyperledger Fabric v1.1 it is also possible to set endorsement policies for peers. Have a look at the official <a href="http://hyperledger-fabric.readthedocs.io/en/release-1.1/endorsement-policies.html">documentation</a> for v1.1.</p>
                <p>To use this new feature, first we need to change the <code className="hljs hl-inline">crypto-config.yaml</code> and add <code className="hljs hl-inline">EnableNodeOUs</code>:</p>
                <pre><code className="hljs ">{"\n"}OrdererOrgs:{"\n"}{"  "}- Name: Orderer{"\n"}{"    "}Domain: pcxchg.com{"\n"}{"    "}Specs:{"\n"}{"      "}- Hostname: orderer{"\n"}PeerOrgs:{"\n"}{"  "}- Name: Asus{"\n"}{"    "}Domain: Asus.com{"\n"}{"    "}EnableNodeOUs: true{"\n"}{"    "}Template:{"\n"}{"      "}Count: 1{"\n"}{"    "}Users:{"\n"}{"      "}Count: 1{"\n"}{"  "}- Name: Amazon{"\n"}{"    "}Domain: Amazon.com{"\n"}{"    "}EnableNodeOUs: true{"\n"}{"    "}Template:{"\n"}{"      "}Count: 1{"\n"}{"    "}Users:{"\n"}{"      "}Count: 1{"\n"}{"  "}- Name: Dell{"\n"}{"    "}Domain: Dell.com{"\n"}{"    "}EnableNodeOUs: true{"\n"}{"    "}Template:{"\n"}{"      "}Count: 1{"\n"}{"    "}Users:{"\n"}{"      "}Count: 1{"\n"}{"  "}- Name: HP{"\n"}{"    "}Domain: HP.com{"\n"}{"    "}EnableNodeOUs: true{"\n"}{"    "}Template:{"\n"}{"      "}Count: 1{"\n"}{"    "}Users:{"\n"}{"      "}Count: 1{"\n"}</code></pre>
                <p>With this new configuration you should regenerate the certificates. Now we also need to change the <code className="hljs hl-inline">configtx.yaml</code>:</p>
                <pre><code className="hljs ">{"\n"}Profiles:{"\n"}{"\n"}{"    "}PCXCHGOrdererGenesis:{"\n"}{"        "}Capabilities:{"\n"}{"            "}&lt;&lt;: *ChannelCapabilities{"\n"}{"        "}Orderer:{"\n"}{"            "}&lt;&lt;: *OrdererDefaults{"\n"}{"            "}Organizations:{"\n"}{"                "}- *OrdererOrg{"\n"}{"            "}Capabilities:{"\n"}{"                "}&lt;&lt;: *OrdererCapabilities{"\n"}{"        "}Consortiums:{"\n"}{"            "}PCXCHG:{"\n"}{"                "}Organizations:{"\n"}{"                    "}- *Asus{"\n"}{"                    "}- *Dell{"\n"}{"                    "}- *HP{"\n"}{"                    "}- *Amazon{"\n"}{"\n"}{"    "}AsusChannel:{"\n"}{"        "}Consortium: PCXCHG{"\n"}{"        "}Application:{"\n"}{"            "}&lt;&lt;: *ApplicationDefaults{"\n"}{"            "}Organizations:{"\n"}{"                "}- *Asus{"\n"}{"                "}- *Amazon{"\n"}{"            "}Capabilities:{"\n"}{"                "}&lt;&lt;: *ApplicationCapabilities{"\n"}{"    "}DellChannel:{"\n"}{"        "}Consortium: PCXCHG{"\n"}{"        "}Application:{"\n"}{"            "}&lt;&lt;: *ApplicationDefaults{"\n"}{"            "}Organizations:{"\n"}{"                "}- *Dell{"\n"}{"                "}- *Amazon{"\n"}{"            "}Capabilities:{"\n"}{"                "}&lt;&lt;: *ApplicationCapabilities{"\n"}{"    "}HPChannel:{"\n"}{"        "}Consortium: PCXCHG{"\n"}{"        "}Application:{"\n"}{"            "}&lt;&lt;: *ApplicationDefaults{"\n"}{"            "}Organizations:{"\n"}{"                "}- *HP{"\n"}{"                "}- *Amazon{"\n"}{"            "}Capabilities:{"\n"}{"                "}&lt;&lt;: *ApplicationCapabilities{"\n"}Organizations:{"\n"}{"\n"}{"    "}- &amp;OrdererOrg{"\n"}{"        "}Name: OrdererMSP{"\n"}{"        "}ID: OrdererMSP{"\n"}{"\n"}{"        "}MSPDir: crypto-config/ordererOrganizations/pcxchg.com/msp{"\n"}{"\n"}{"    "}- &amp;Asus{"\n"}{"        "}Name: AsusMSP{"\n"}{"        "}ID: AsusMSP{"\n"}{"\n"}{"        "}MSPDir: crypto-config/peerOrganizations/Asus.com/msp{"\n"}{"\n"}{"        "}AnchorPeers:{"\n"}{"            "}- Host: peer0.Asus.com{"\n"}{"              "}Port: 7051{"\n"}{"\n"}{"    "}- &amp;Amazon{"\n"}{"        "}Name: AmazonMSP{"\n"}{"        "}ID: AmazonMSP{"\n"}{"\n"}{"        "}MSPDir: crypto-config/peerOrganizations/Amazon.com/msp{"\n"}{"\n"}{"        "}AnchorPeers:{"\n"}{"            "}- Host: peer0.Amazon.com{"\n"}{"              "}Port: 7051{"\n"}{"\n"}{"    "}- &amp;Dell{"\n"}{"        "}Name: DellMSP{"\n"}{"        "}ID: DellMSP{"\n"}{"\n"}{"        "}MSPDir: crypto-config/peerOrganizations/Dell.com/msp{"\n"}{"\n"}{"        "}AnchorPeers:{"\n"}{"            "}- Host: peer0.Dell.com{"\n"}{"              "}Port: 7051{"\n"}{"\n"}{"    "}- &amp;HP{"\n"}{"        "}Name: HPMSP{"\n"}{"        "}ID: HPMSP{"\n"}{"\n"}{"        "}MSPDir: crypto-config/peerOrganizations/HP.com/msp{"\n"}{"\n"}{"        "}AnchorPeers:{"\n"}{"            "}- Host: peer0.HP.com{"\n"}{"              "}Port: 7051{"\n"}{"\n"}Orderer: &amp;OrdererDefaults{"\n"}{"    "}OrdererType: solo{"\n"}{"\n"}{"    "}Addresses:{"\n"}{"        "}- orderer.pcxchg.com:7050{"\n"}{"\n"}{"    "}BatchTimeout: 2s{"\n"}{"\n"}{"    "}BatchSize:{"\n"}{"\n"}{"        "}MaxMessageCount: 10{"\n"}{"        "}AbsoluteMaxBytes: 99 MB{"\n"}{"        "}PreferredMaxBytes: 512 KB{"\n"}{"\n"}{"    "}Organizations:{"\n"}{"\n"}{"\n"}Application: &amp;ApplicationDefaults{"\n"}{"    "}Organizations:{"\n"}{"\n"}Capabilities:{"\n"}{"\n"}{"    "}Global: &amp;ChannelCapabilities{"\n"}{"        "}V1_1: true{"\n"}{"\n"}{"    "}Orderer: &amp;OrdererCapabilities{"\n"}{"        "}V1_1: true{"\n"}{"\n"}{"    "}Application: &amp;ApplicationCapabilities{"\n"}{"        "}V1_1: true{"\n"}</code></pre>
                <p>Now you can generate the artifacts and initiate a chaincode like:</p>
                <pre><code className="hljs ">{"\n"}peer chaincode instantiate -C asus -n pcxchg -v 0 -c '{"{"}"Args":[]{"}"}' -P "OR ('AmazonMSP.peer', 'AsusMSP.peer')"{"\n"}</code></pre>
                <p>So if we invoke the chaincode, we will need a signature from an Amazon or Asus peer.</p>
                <p>[1] Contributed by IBM and Digital Asset Holdings, Hyperledger Fabric is one of five Hyperledger Projects hosted by The Linux Foundation.</p>
            </div>
        )
    }
}

export default AccessControl;