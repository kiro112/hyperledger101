import React, { Component } from 'react';

class Next extends Component {

    render () {
        return (
            <div className="xblock xblock-student_view xblock-student_view-vertical" data-runtime-class="LmsRuntime" data-init="VerticalStudentView" data-course-id="course-v1:B9lab+HLF-12+2018-07" data-request-token="f5c9e4ca9e8a11e8be140a059cba8688" data-runtime-version={1} data-usage-id="block-v1:B9lab+HLF-12+2018-07+type@vertical+block@4e14a56597384488a05808706ef2a7ff" data-block-type="vertical">
                <h3 className="unit-title">Unit</h3>
                <div className="vert-mod">
                <div className="vert vert-0" data-id="block-v1:B9lab+HLF-12+2018-07+type@html+block@f51f835f9fce414fb4a32778fadd8e3f">
                    <div className="xblock xblock-student_view xblock-student_view-html xmodule_display xmodule_HtmlModule" data-runtime-class="LmsRuntime" data-init="XBlockToXModuleShim" data-block-type="html" data-request-token="f5c9e4ca9e8a11e8be140a059cba8688" data-runtime-version={1} data-usage-id="block-v1:B9lab+HLF-12+2018-07+type@html+block@f51f835f9fce414fb4a32778fadd8e3f" data-type="HTMLModule" data-course-id="course-v1:B9lab+HLF-12+2018-07">
                    <h2>Next Steps</h2>
                    <p>You now know how to invoke and query chaincodes with the HFC SDK. This is the most important task for a client. So, your program will be visible to the user and therefore you should practice creating attractive UIs.</p>
                    <p>Here are some useful links for you to create a UI:</p>
                    <ul>
                        <li><a href="https://github.com/nwjs/nw.js">NW.js</a></li>
                        <li><a href="http://appjs.com/">AppJS</a></li>
                        <li><a href="https://github.com/arturadib/node-qt">Node-Qt</a></li>
                    </ul>
                    <p>You should now be able to understand the first test, <code className="hljs hl-inline">balance-transfer/app.js</code>.</p>
                    <p>You can see:</p>
                    <ul>
                        <li><code className="hljs hl-inline">create-channel.js</code>: how to create channels</li>
                        <li><code className="hljs hl-inline">join-channel.js</code>: how to join peers into channels</li>
                        <li><code className="hljs hl-inline">install-chaincode.js</code>: how to install chaincodes on peers</li>
                        <li><code className="hljs hl-inline">instantiate-chaincode.js</code>: how to instantiate chaincodes on channels</li>
                    </ul>
                    <p>A look into HFC SDK <a href="https://github.com/hyperledger/fabric-sdk-node/tree/master/test/integration">integration tests</a> may also help you see how to use the different SDK functions available.</p>
                    <p>We will come back to <strong>fabric-ca-client</strong> in the next module, when we discuss <strong>Fabric-CA</strong>. </p>
                    <p>We used promises to write our client. If you are interested in seeing how the same can be done using <code className="hljs hl-inline">async</code>/<code className="hljs hl-inline">await</code> instead, <a href="https://ksachdeva.github.io/2017/07/23/bootstrapping-hyperledger-fabric-nw-4/">this</a> is a good example. </p>
                    <p>For now, there is one last thing we want to talk about.</p>
                    <h3>Events</h3>
                    <p>HFC SDK offers an <a href="https://github.com/hyperledger/fabric-sdk-node/blob/46fc443fa8560032e8e77d4689581718190926c5/fabric-client/lib/EventHub.js">EventHub</a>. We can use it to get an event, if a transaction is commited. This is the last part of the transaction flow. We will need to set up the event listener before we broadcast the transaction to the orderer. </p>
                    <p>You already came across this in the examples although we did not talk about it. </p>
                    <p>How does it work? Here is an overview:</p>
                    <p><img src="https://s3-eu-west-1.amazonaws.com/b9-academy-assets/course-assets/HLF-0/eventHub.png" /></p>
                    <p>Now, let us implement this:</p>
                    <pre><code className="hljs javascript">{"\n"}const initEventHub = function(client, eventUrl) {"{"}{"\n"}{"  "}const eh = client.newEventHub();{"\n"}{"  "}eh.setPeerAddr(eventUrl);{"\n"}{"  "}eh.connect();{"\n"}{"  "}return eh;{"\n"}{"}"};{"\n"}{"\n"}const catchEvent = function(eh, transactionID, timeout) {"{"}{"\n"}{"  "}return new Promise((resolve, reject) =&gt; {"{"}{"\n"}{"    "}const handle = setTimeout({"\n"}{"      "}() =&gt; {"{"}{"\n"}{"        "}eh.unregisterTxEvent(transactionID);{"\n"}{"        "}eh.disconnect();{"\n"}{"        "}reject("Timed out");{"\n"}{"      "}{"}"},{"\n"}{"      "}timeout);{"\n"}{"\n"}{"    "}const txId = transactionID.getTransactionID();{"\n"}{"    "}eh.registerTxEvent(txId, (tx, code) =&gt; {"{"}{"\n"}{"      "}clearTimeout(handle);{"\n"}{"      "}eh.unregisterTxEvent(transactionID);{"\n"}{"      "}eh.disconnect();{"\n"}{"\n"}{"      "}if (code == 'VALID'){"\n"}{"        "}return resolve("Transaction is in a block.");{"\n"}{"      "}reject("Transaction is rejected. Code: " + code.toString());{"\n"}{"    "}{"}"});{"\n"}{"\n"}{"  "}{"}"});{"\n"}{"}"};{"\n"}</code></pre>
                    <p>We have two anonymous functions as callbacks:</p>
                    <ul>
                        <li>First for the <code className="hljs hl-inline">setTimeout</code>, we reject the promise if we hit the timeout.</li>
                        <li>Second for the <code className="hljs hl-inline">registerTxEvent</code>, this one will yield when the transaction has been committed. The <code className="hljs hl-inline">code</code> argument tells us whether the transaction is valid.</li>
                    </ul>
                    <p>Of course we need to adjust our code to use <code className="hljs hl-inline">initEventHub</code> and <code className="hljs hl-inline">catchEvent</code>. We recommend that you extend the <code className="hljs hl-inline">producerApp.js</code> yourself.</p>
                    <p>At the end, <code className="hljs hl-inline">producerApp.js</code> should look like:</p>
                    <pre><code className="hljs javascript">{"\n"}'use strict'; // self-defence{"\n"}{"\n"}// Functions from figure{"\n"}const hfc = require('fabric-client');{"\n"}{"\n"}const target = [];{"\n"}const client = new hfc();{"\n"}let channel;{"\n"}{"\n"}const enrolUser = function(client, options) {"{"}{"\n"}{"  "}return hfc.newDefaultKeyValueStore({"{"} path: options.wallet_path {"}"}){"\n"}{"    "}.then(wallet =&gt; {"{"}{"\n"}{"      "}client.setStateStore(wallet);{"\n"}{"      "}return client.getUserContext(options.user_id, true);{"\n"}{"    "}{"}"});{"\n"}{"}"};{"\n"}{"\n"}const initNetwork = function(client, options, target) {"{"}{"\n"}{"  "}let channel;{"\n"}{"  "}try {"{"}{"\n"}{"    "}channel = client.newChannel(options.channel_id);{"\n"}{"    "}const peer = client.newPeer(options.peer_url);{"\n"}{"    "}target = peer;{"\n"}{"    "}channel.addPeer(peer);{"\n"}{"    "}channel.addOrderer(client.newOrderer(options.orderer_url));{"\n"}{"  "}{"}"} catch(e) {"{"} // channel already exists{"\n"}{"    "}channel= client.getChannel(options.channel_id);{"\n"}{"  "}{"}"}{"\n"}{"  "}return channel;{"\n"}{"}"};{"\n"}{"\n"}const transactionProposal = function(client, channel, request) {"{"}{"\n"}{"  "}request.txId = client.newTransactionID();{"\n"}{"  "}return channel.sendTransactionProposal(request);{"\n"}{"}"};{"\n"}{"\n"}const responseInspect = function(results) {"{"}{"\n"}{"  "}const proposalResponses = results[0];{"\n"}{"  "}const proposal = results[1];{"\n"}{"  "}const header = results[2];{"\n"}{"\n"}{"  "}if (proposalResponses &amp;&amp; proposalResponses.length &gt; 0 &amp;&amp;{"\n"}{"    "}proposalResponses[0].response &amp;&amp;{"\n"}{"    "}proposalResponses[0].response.status === 200) {"{"}{"\n"}{"    "}return true;{"\n"}{"  "}{"}"}{"\n"}{"  "}return false;{"\n"}{"}"};{"\n"}{"\n"}const sendOrderer = function(channel, request) {"{"}{"\n"}{"  "}return channel.sendTransaction(request);{"\n"}{"}"};{"\n"}{"\n"}const initEventHub = function(client, eventUrl) {"{"}{"\n"}{"  "}const eh = client.newEventHub();{"\n"}{"  "}eh.setPeerAddr(eventUrl);{"\n"}{"  "}eh.connect();{"\n"}{"  "}return eh;{"\n"}{"}"};{"\n"}{"\n"}const catchEvent = function(eh, transactionID, timeout) {"{"}{"\n"}{"  "}return new Promise((resolve, reject) =&gt; {"{"}{"\n"}{"    "}const handle = setTimeout({"\n"}{"      "}() =&gt; {"{"}{"\n"}{"        "}eh.unregisterTxEvent(transactionID);{"\n"}{"        "}eh.disconnect();{"\n"}{"        "}reject("Timed out");{"\n"}{"      "}{"}"},{"\n"}{"      "}timeout);{"\n"}{"\n"}{"    "}const txId = transactionID.getTransactionID();{"\n"}{"    "}eh.registerTxEvent(txId, (tx, code) =&gt; {"{"}{"\n"}{"      "}clearTimeout(handle);{"\n"}{"      "}eh.unregisterTxEvent(transactionID);{"\n"}{"      "}eh.disconnect();{"\n"}{"\n"}{"      "}if (code == 'VALID'){"\n"}{"        "}return resolve("Transaction is in a block.");{"\n"}{"      "}reject("Transaction is rejected. Code: " + code.toString());{"\n"}{"    "}{"}"});{"\n"}{"\n"}{"  "}{"}"});{"\n"}{"}"};{"\n"}{"\n"}// Function invokes createPC on pcxchg{"\n"}function invoke(opt, param) {"{"}{"\n"}{"  "}return enrolUser(client, opt){"\n"}{"    "}.then(user =&gt; {"{"}{"\n"}{"      "}if(typeof user === "undefined" || !user.isEnrolled()){"\n"}{"        "}throw "User not enrolled";{"\n"}{"\n"}{"      "}channel = initNetwork(client, opt, target);{"\n"}{"      "}const request = {"{"}{"\n"}{"          "}targets: target,{"\n"}{"          "}chaincodeId: opt.chaincode_id,{"\n"}{"          "}fcn: 'createPC',{"\n"}{"          "}args: param,{"\n"}{"          "}chainId: opt.channel_id,{"\n"}{"          "}txId: null{"\n"}{"      "}{"}"};{"\n"}{"      "}return transactionProposal(client, channel, request){"\n"}{"        "}.then(results =&gt; {"{"}{"\n"}{"          "}if (responseInspect(results)) {"{"}{"\n"}{"            "}const broadcastRequest = {"{"}{"\n"}{"              "}proposalResponses: results[0],{"\n"}{"              "}proposal: results[1],{"\n"}{"              "}header: results[2]{"\n"}{"            "}{"}"};{"\n"}{"\n"}{"            "}let eh = initEventHub(client, opt.event_url);{"\n"}{"\n"}{"            "}return Promise.all([{"\n"}{"              "}sendOrderer(channel, broadcastRequest),{"\n"}{"              "}catchEvent(eh, request.txId, 6000){"\n"}{"            "}]);{"\n"}{"          "}{"}"} else {"{"}{"\n"}{"            "}throw "Bad Response";{"\n"}{"          "}{"}"}{"\n"}{"        "}{"}"});{"\n"}{"    "}{"}"}){"\n"}{"    "}.catch(err =&gt; {"{"}{"\n"}{"      "}console.log(err);{"\n"}{"      "}throw err;{"\n"}{"    "}{"}"});{"\n"}{"}"};{"\n"}{"\n"}var options = {"{"}{"\n"}{"  "}Asus : {"{"}{"\n"}{"    "}wallet_path: '&lt;YOUR APP PATH&gt;/producerApp/certs',{"\n"}{"    "}user_id: 'AsusAdmin',{"\n"}{"    "}channel_id: 'asus',{"\n"}{"    "}chaincode_id: 'pcxchg',{"\n"}{"    "}peer_url: 'grpc://localhost:7051',{"\n"}{"    "}orderer_url: 'grpc://localhost:7050',{"\n"}{"    "}event_url: 'grpc://localhost:7053'{"\n"}{"  "}{"}"},{"\n"}{"  "}Hp : {"{"}{"\n"}{"    "}wallet_path: '&lt;YOUR APP PATH&gt;/producerApp/certs',{"\n"}{"    "}user_id: 'HpAdmin',{"\n"}{"    "}channel_id: 'hp',{"\n"}{"    "}chaincode_id: 'pcxchg',{"\n"}{"    "}peer_url: 'grpc://localhost:9051',{"\n"}{"    "}orderer_url: 'grpc://localhost:7050',{"\n"}{"    "}event_url: 'grpc://localhost:9053'{"\n"}{"  "}{"}"},{"\n"}{"  "}Dell : {"{"}{"\n"}{"    "}wallet_path: '&lt;YOUR APP PATH&gt;/producerApp/certs',{"\n"}{"    "}user_id: 'DellAdmin',{"\n"}{"    "}channel_id: 'dell',{"\n"}{"    "}chaincode_id: 'pcxchg',{"\n"}{"    "}peer_url: 'grpc://localhost:10051',{"\n"}{"    "}orderer_url: 'grpc://localhost:7050',{"\n"}{"    "}event_url: 'grpc://localhost:10053'{"\n"}{"  "}{"}"}{"\n"}{"}"};{"\n"}{"\n"}// Server{"\n"}const express = require("express");{"\n"}const app = express();{"\n"}const http = require('http');{"\n"}const bodyParser = require('body-parser');{"\n"}const path = require('path');{"\n"}{"\n"}app.engine('html', require('ejs').renderFile);{"\n"}{"\n"}const server = http.createServer(app).listen(4000, function() {"{"}{"}"});{"\n"}app.use(bodyParser.json());{"\n"}app.use(bodyParser.urlencoded({"{"} extended: true {"}"}));{"\n"}app.use(express.static(__dirname));{"\n"}app.set('views', __dirname);{"\n"}{"\n"}app.post('/invoke', function(req, res, next) {"{"}{"\n"}{"  "}const args = req.body.args;{"\n"}{"  "}invoke(options[args[0]], args.slice(1)){"\n"}{"    "}.then(result =&gt; res.send(result)){"\n"}{"    "}.catch(err =&gt; {"{"}{"\n"}{"      "}res.status(500);{"\n"}{"      "}res.send(err.toString());{"\n"}{"    "}{"}"});{"\n"}{"}"});{"\n"}{"\n"}app.get('/', function(req, res) {"{"}{"\n"}{"  "}res.render('UI.html');{"\n"}{"}"});{"\n"}</code></pre>
                    <p>Like we mentioned before, we have to put this between <code className="hljs hl-inline">sendTransactionProposal</code> and <code className="hljs hl-inline">sendTransaction</code>. But it will get the event after <code className="hljs hl-inline">sendTransaction</code>. So, that is why we use:</p>
                    <pre><code className="hljs javascript">{"\n"}Promise.all([{"\n"}{"  "}sendOrderer(channel, broadcastRequest),{"\n"}{"  "}catchEvent(eh, request.txId, 6000){"\n"}]);{"\n"}</code></pre>
                    <p>This way, <code className="hljs hl-inline">catchEvent</code> will start to listen, before <code className="hljs hl-inline">sendOrderer</code> is done. But will wait, until the time is up or the transaction is commited. Try this, you should get a message other than <code className="hljs hl-inline">"Chaincode invoke"</code>, if you create a PC.</p>
                    </div>
                </div>
                </div>
            </div>
        );
    }
}

export default Next;